import{s as g,r as f,u as N}from"./index-Caw7KGCA.js";const _={async fetchChallenges(e){console.log("Fetching challenges for user:",e);const{data:o,error:n}=await g.from("challenges").select(`
        *,
        challenger_profile:user_profiles!challenger_id(name, username, avatar_url),
        opponent_profile:user_profiles!opponent_id(name, username, avatar_url)
      `).or(`challenger_id.eq.${e},opponent_id.eq.${e}`).order("created_at",{ascending:!1});if(n)throw console.error("Error fetching challenges:",n),n;return console.log("Fetched challenges:",o),o||[]},async createChallenge(e,o,n,l){console.log("=== CHALLENGE CREATION DEBUG START ==="),console.log("Creating challenge:",{challengerId:e,challengeLength:o,inviteMethod:n,username:l});try{console.log("Step 1: Generating invite token...");const{data:r,error:C}=await g.rpc("generate_invite_token");if(C)throw console.error("❌ Step 1 FAILED: Token generation error:",C),new Error("Failed to generate invite token");const i=r;console.log("✅ Step 1 SUCCESS: Generated token:",i);const t=new Date;if(t.setHours(t.getHours()+24),console.log("Step 2: Setting expiration to:",t.toISOString()),n==="username"&&l){console.log("Step 3: Validating username:",l);const{data:w,error:L}=await g.from("user_profiles").select("id, username").eq("username",l.toLowerCase()).neq("id",e).maybeSingle();if(L)throw console.error("❌ Step 3 FAILED: Username validation error:",L),new Error("Failed to validate username");if(!w)throw console.log("❌ Step 3 FAILED: Username not found"),new Error("Username not found");console.log("✅ Step 3 SUCCESS: Username validated:",w)}console.log("Step 4: Creating challenge in database...");const s={challenger_id:e,challenge_length:o,start_date:new Date().toISOString().split("T")[0],end_date:new Date(Date.now()+(o-1)*24*60*60*1e3).toISOString().split("T")[0],invite_token:i,invite_expires_at:t.toISOString(),invited_username:n==="username"?l:null,status:"pending"};console.log("Challenge data to insert:",s);const{data:p,error:E}=await g.from("challenges").insert(s).select(`
          *,
          challenger_profile:user_profiles!challenger_id(name, username, avatar_url)
        `).single();if(E)throw console.error("❌ Step 4 FAILED: Challenge creation error:",E),E;console.log("✅ Step 4 SUCCESS: Challenge created:",p),console.log("Step 5: Verifying token was saved...");const{data:d,error:a}=await g.from("challenges").select("id, invite_token").eq("id",p.id).single();return a||!d?console.error("❌ Step 5 FAILED: Token verification failed:",a):console.log("✅ Step 5 SUCCESS: Token verified in DB:",d.invite_token),console.log("=== CHALLENGE CREATION DEBUG END ==="),p}catch(r){throw console.error("💥 CRITICAL ERROR in createChallenge:",r),console.log("=== CHALLENGE CREATION DEBUG END ==="),r}},async generateInviteToken(){console.log("Generating new invite token...");const{data:e,error:o}=await g.rpc("generate_invite_token");if(o)throw console.error("Error generating invite token:",o),o;return console.log("Generated invite token:",e),e},async cancelChallenge(e,o){console.log("Canceling challenge:",e,"for user:",o);const{error:n}=await g.from("challenges").update({status:"cancelled",updated_at:new Date().toISOString()}).eq("id",e).eq("challenger_id",o).eq("status","pending");return n?(console.error("Error canceling challenge:",n),!1):(console.log("Challenge canceled successfully"),!0)},async updateChallengePoints(e){console.log("Updating challenge points for:",e.id);const o=await this.calculateUserPoints(e.challenger_id,e.start_date,e.end_date),n=e.opponent_id?await this.calculateUserPoints(e.opponent_id,e.start_date,e.end_date):0,{error:l}=await g.from("challenges").update({challenger_points:o,opponent_points:n,updated_at:new Date().toISOString()}).eq("id",e.id);if(l)throw console.error("Error updating challenge points:",l),l;console.log("Challenge points updated successfully")},async calculateUserPoints(e,o,n){const{data:l,error:r}=await g.rpc("calculate_challenge_points",{user_uuid:e,start_date_param:o,end_date_param:n});return r?(console.error("Error calculating user points:",r),0):l||0}},D={async validateChallengeToken(e){var o,n;console.log("=== TOKEN VALIDATION DEBUG START ==="),console.log("API: Validating challenge token:",e);try{console.log("Step 1: Expiring old challenges...");const{error:l}=await g.rpc("expire_old_challenges");l?console.warn("⚠️ Warning: Failed to expire old challenges:",l):console.log("✅ Step 1 SUCCESS: Old challenges expired"),console.log("Step 2a: Checking if token exists at all...");const{data:r,error:C}=await g.from("challenges").select("id, status, opponent_id, invite_expires_at, challenger_id, invite_token").eq("invite_token",e);C?console.error("❌ Step 2a FAILED: Error checking token existence:",C):(console.log("🔍 Step 2a DEBUG: All challenges with this token:",r),!r||r.length===0?(console.log("❌ PROBLEM IDENTIFIED: No challenge found with this token at all"),console.log("This suggests the token was never saved to the database during challenge creation")):r.forEach((s,p)=>{console.log(`🔍 Challenge ${p+1}:`,{id:s.id,status:s.status,opponent_id:s.opponent_id,challenger_id:s.challenger_id,invite_expires_at:s.invite_expires_at,is_expired:new Date(s.invite_expires_at)<=new Date,invite_token:s.invite_token})})),console.log("Step 2b: Clearing Supabase cache for challenges table..."),await g.auth.refreshSession(),console.log("Step 2c: Fetching challenge with criteria...");const{data:i,error:t}=await g.from("challenges").select(`
          *,
          challenger_profile:user_profiles!challenger_id(name, username, avatar_url)
        `).eq("invite_token",e).eq("status","pending").is("opponent_id",null).gt("invite_expires_at",new Date().toISOString()).maybeSingle();if(t)throw console.error("❌ Step 2c FAILED: Error validating token:",t),t;return i?(console.log("✅ Step 2c SUCCESS: Valid challenge found:",{id:i.id,status:i.status,challenger_id:i.challenger_id,opponent_id:i.opponent_id,invite_expires_at:i.invite_expires_at,challenger_name:((o=i.challenger_profile)==null?void 0:o.name)||((n=i.challenger_profile)==null?void 0:n.username)}),console.log("=== TOKEN VALIDATION DEBUG END ==="),i):(console.log("❌ Step 2c FAILED: No valid challenge found for token"),console.log("Possible reasons:"),console.log("- Token does not exist"),console.log('- Challenge status is not "pending"'),console.log("- Challenge already has an opponent"),console.log("- Invite has expired"),console.log("=== TOKEN VALIDATION DEBUG END ==="),null)}catch(l){throw console.error("💥 CRITICAL ERROR in validateChallengeToken:",l),console.log("=== TOKEN VALIDATION DEBUG END ==="),l}},async validateUsernameExists(e,o){const{data:n,error:l}=await g.from("user_profiles").select("id").eq("username",e.toLowerCase()).neq("id",o).maybeSingle();if(l)throw l;return!!n}},m={async joinChallengeByToken(e,o){console.log("=== CHALLENGE JOIN DEBUG START ==="),console.log("API: Attempting to join challenge with token:",e,"for user:",o);try{await g.auth.refreshSession(),console.log("Step 1: Validating challenge token...");const n=await D.validateChallengeToken(e);if(!n)return console.log("❌ Step 1 FAILED: Token validation failed - challenge not found or expired"),{success:!1,error:"Challenge not found, expired, or already joined"};if(console.log("✅ Step 1 SUCCESS: Valid challenge found:",{id:n.id,status:n.status,challenger_id:n.challenger_id,opponent_id:n.opponent_id,invite_expires_at:n.invite_expires_at}),n.challenger_id===o)return console.log("❌ Step 2 FAILED: User trying to join own challenge"),{success:!1,error:"Cannot join your own challenge"};if(console.log("✅ Step 2 SUCCESS: User is not the challenger"),n.opponent_id)return console.log("❌ Step 3 FAILED: Challenge already has opponent:",n.opponent_id),{success:!1,error:"Challenge already has an opponent"};if(console.log("✅ Step 3 SUCCESS: Challenge has no opponent yet"),n.status!=="pending")return console.log("❌ Step 4 FAILED: Challenge status is not pending:",n.status),{success:!1,error:"Challenge is no longer available"};console.log("✅ Step 4 SUCCESS: Challenge status is pending"),console.log("Step 5: Attempting RPC join...");const{data:l,error:r}=await g.rpc("join_challenge_by_token",{token:e,joiner_id:o});return r?(console.log("⚠️ Step 5 RPC FAILED:",r.message),console.log("Falling back to manual join..."),await this.manualJoinChallenge(n.id,o)):(console.log("✅ Step 5 RPC SUCCESS:",l),console.log("=== CHALLENGE JOIN DEBUG END ==="),l)}catch(n){throw console.error("💥 CRITICAL ERROR in joinChallengeByToken:",n),console.log("=== CHALLENGE JOIN DEBUG END ==="),n}},async manualJoinChallenge(e,o){console.log("=== MANUAL JOIN DEBUG START ==="),console.log("API: Attempting manual join for challenge:",e,"user:",o);try{console.log("Step 1: Checking current challenge state...");const{data:n,error:l}=await g.from("challenges").select("*").eq("id",e).single();if(l)return console.error("❌ Step 1 FAILED: Error fetching challenge:",l),{success:!1,error:"Failed to fetch challenge details"};if(console.log("✅ Step 1 SUCCESS: Current challenge state:",{id:n.id,status:n.status,opponent_id:n.opponent_id,challenger_id:n.challenger_id}),n.status!=="pending")return console.log("❌ Step 2 FAILED: Challenge status is not pending:",n.status),{success:!1,error:"Challenge is no longer pending"};if(n.opponent_id)return console.log("❌ Step 3 FAILED: Challenge already has opponent:",n.opponent_id),{success:!1,error:"Challenge already has an opponent"};console.log("✅ Steps 2-3 SUCCESS: Challenge is still available for joining"),console.log("Step 4: Updating challenge with opponent...");const{data:r,error:C}=await g.from("challenges").update({opponent_id:o,status:"active",updated_at:new Date().toISOString()}).eq("id",e).eq("status","pending").is("opponent_id",null).select().single();return C?(console.error("❌ Step 4 FAILED: Manual join update failed:",C),{success:!1,error:"Failed to join challenge - database error"}):r?(console.log("✅ Step 4 SUCCESS: Manual join successful:",{id:r.id,status:r.status,opponent_id:r.opponent_id}),console.log("=== MANUAL JOIN DEBUG END ==="),{success:!0,challenge_id:e}):(console.log("❌ Step 4 FAILED: No data returned - challenge may have been taken by someone else"),{success:!1,error:"Challenge no longer available - may have been taken by another user"})}catch(n){return console.error("💥 CRITICAL ERROR in manual join:",n),console.log("=== MANUAL JOIN DEBUG END ==="),{success:!1,error:"Failed to join challenge - unexpected error"}}}},A={fetchChallenges:_.fetchChallenges,createChallenge:_.createChallenge,generateInviteToken:_.generateInviteToken,cancelChallenge:_.cancelChallenge,updateChallengePoints:_.updateChallengePoints,joinChallengeByToken:m.joinChallengeByToken,manualJoinChallenge:m.manualJoinChallenge,validateChallengeToken:D.validateChallengeToken},I=()=>{const[e,o]=f.useState({challenges:[],activeChallenge:null,pastChallenges:[],isLoading:!1,error:null}),n=f.useCallback(t=>{o(s=>({...s,isLoading:t}))},[]),l=f.useCallback(t=>{o(s=>({...s,error:t}))},[]),r=f.useCallback(t=>{console.log("Updating challenges with data:",t);const s=t.find(a=>a.status==="active"),p=s?null:t.find(a=>a.status==="pending"),E=s||p,d=t.filter(a=>a.status==="completed"||a.status==="expired"||a.status==="pending"&&a!==E);console.log("Active challenge determined:",E),console.log("Past challenges:",d),o(a=>({...a,challenges:t,activeChallenge:E,pastChallenges:d}))},[]),C=f.useCallback(()=>{console.log("Clearing active challenge"),o(t=>({...t,activeChallenge:null}))},[]),i=f.useCallback(t=>{console.log("Removing challenge by ID:",t),o(s=>{const p=s.challenges.filter(a=>a.id!==t),E=p.find(a=>a.status==="active")||p.find(a=>a.status==="pending"),d=p.filter(a=>a.status==="completed"||a.status==="expired"||a.status==="pending"&&a!==E);return{...s,challenges:p,activeChallenge:E,pastChallenges:d}})},[]);return{...e,setIsLoading:n,setError:l,updateChallenges:r,clearActiveChallenge:C,removeChallengeById:i}},U=()=>{const{user:e}=N(),{challenges:o,activeChallenge:n,pastChallenges:l,isLoading:r,error:C,setError:i,setIsLoading:t,updateChallenges:s,clearActiveChallenge:p,removeChallengeById:E}=I(),d=async()=>{if(e!=null&&e.id)try{t(!0),i(null),console.log("🔄 CHALLENGES: Fetching challenges for user ID:",e.id);const c=await A.fetchChallenges(e.id);console.log("✅ CHALLENGES: Fetched challenges:",c),s(c)}catch(c){console.error("❌ CHALLENGES: Error fetching challenges:",c),i(c instanceof Error?c.message:"Failed to fetch challenges")}finally{t(!1)}},a=async(c,h,S)=>{if(!(e!=null&&e.id))return null;try{console.log("🔄 CHALLENGES: Creating challenge with length:",c);const u=await A.createChallenge(e.id,c,h,S);if(console.log("✅ CHALLENGES: Challenge created successfully:",u),u)return await d(),u;throw new Error("No data returned from API")}catch(u){throw console.error("❌ CHALLENGES: Error creating challenge:",u),i(u instanceof Error?u.message:"Failed to create challenge"),u}},w=async(c,h)=>{const S=h||(e==null?void 0:e.id);if(!S)return{success:!1,error:"Not authenticated"};try{console.log("🔄 CHALLENGES: Attempting to join challenge with token:",c);const v=await A.joinChallengeByToken(c,S);return v.success?(console.log("✅ CHALLENGES: Successfully joined challenge, refreshing data..."),await d(),{success:!0,challenge_id:v.challenge_id}):(console.log("❌ CHALLENGES: Failed to join challenge:",v.error),{success:!1,error:v.error})}catch(u){return console.error("❌ CHALLENGES: Error joining challenge:",u),{success:!1,error:u instanceof Error?u.message:"Failed to join challenge"}}},L=async c=>(await d(),!0),y=async c=>{if(!(e!=null&&e.id))return!1;try{console.log("🔄 CHALLENGES: Attempting to cancel challenge:",c),E(c),p();const h=await A.cancelChallenge(c,e.id);return h?console.log("✅ CHALLENGES: Challenge canceled successfully"):(console.log("❌ CHALLENGES: Server cancellation failed, refetching challenges"),await d()),h}catch(h){return console.error("❌ CHALLENGES: Error canceling challenge:",h),i(h instanceof Error?h.message:"Failed to cancel challenge"),await d(),!1}},k=async c=>{try{const h=o.find(S=>S.id===c);if(!h)return;await A.updateChallengePoints(h),await d()}catch(h){console.error("❌ CHALLENGES: Error updating challenge points:",h)}};return f.useEffect(()=>{e!=null&&e.id&&(console.log("🔄 CHALLENGES: User changed, fetching challenges for:",e.id),d())},[e==null?void 0:e.id]),{challenges:o,activeChallenge:n,pastChallenges:l,isLoading:r,error:C,createChallenge:a,cancelChallenge:y,joinChallenge:L,joinChallengeByToken:w,updateChallengePoints:k,refetch:d}};export{A as c,U as u};
